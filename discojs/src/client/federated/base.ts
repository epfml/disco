import createDebug from "debug";

import {
  serialization,
  type WeightsContainer,
} from "../../index.js";
import { Base as Client } from "../base.js";
import { type, type ClientConnected } from "../messages.js";
import {
  type EventConnection,
  waitMessageWithTimeout,
  WebSocketServer,
} from "../event_connection.js";
import * as messages from "./messages.js";

const debug = createDebug("discojs:client:federated");

/**
 * Client class that communicates with a centralized, federated server, when training
 * a specific task in the federated setting.
 */
export class Base extends Client {
  /**
   * Arbitrary node id assigned to the federated server which we are communicating with.
   * Indeed, the server acts as a node within the network. In the federated setting described
   * by this client class, the server is the only node which we are communicating with.
   */
  public static readonly SERVER_NODE_ID = "federated-server-node-id";
  
  // Total number of other federated contributors, including this client, excluding the server
  // E.g., if 3 users are training a federated model, nbOfParticipants is 3
  #nbOfParticipants: number = 1;

  // the number of participants excluding the server
  override get nbOfParticipants(): number {
    return this.#nbOfParticipants
  }

  /**
   * Opens a new WebSocket connection with the server and listens to new messages over the channel
   */
  private async connectServer(url: URL): Promise<EventConnection> {
    const server: EventConnection = await WebSocketServer.connect(
      url,
      messages.isMessageFederated,
      messages.isMessageFederated,
    );

    return server;
  }

  /**
   * Initializes the connection to the server and get our own node id.
   * TODO: In the federated setting, should return the current server-side round
   * for the task.
   */
  async connect(): Promise<void> {
    const serverURL = new URL("", this.url.href);
    switch (this.url.protocol) {
      case "http:":
        serverURL.protocol = "ws:";
        break;
      case "https:":
        serverURL.protocol = "wss:";
        break;
      default:
        throw new Error(`unknown protocol: ${this.url.protocol}`);
    }

    serverURL.pathname += `feai/${this.task.id}`;

    this._server = await this.connectServer(serverURL);
    this.aggregator.registerNode(Base.SERVER_NODE_ID);

    const msg: ClientConnected = {
      type: type.ClientConnected,
    };
    this.server.send(msg);

    const received = await waitMessageWithTimeout(
      this.server,
      type.AssignNodeID,
    );
    debug(`[${received.id}] assign id generated by the server`);
    this._ownId = received.id;
  }

  /**
   * Disconnection process when user quits the task.
   */
  override async disconnect(): Promise<void> {
    await this.server.disconnect();
    this._server = undefined;
    this._ownId = undefined;

    this.aggregator.setNodes(this.aggregator.nodes.delete(Base.SERVER_NODE_ID));

    return Promise.resolve();
  }

  override onRoundBeginCommunication(): Promise<void> {
    // Prepare the result promise for the incoming round
    this.aggregationResult = new Promise((resolve) => this.aggregator.once('aggregation', resolve))

    return Promise.resolve();
  }

  override async onRoundEndCommunication(
    weights: WeightsContainer,
    round: number,
  ): Promise<WeightsContainer> {
    // NB: For now, we suppose a fully-federated setting.

    if (this.aggregationResult === undefined) {
      throw new Error("local aggregation result was not set");
    }

    // Send our local contribution to the server
    // and receive the most recent weights as an answer to our contribution
    const serverResult = await this.sendPayloadAndReceiveResult(
      this.aggregator.makePayloads(weights).first(),
    );

    if (
      serverResult !== undefined &&
      this.aggregator.add(Base.SERVER_NODE_ID, serverResult, round, 0)
    ) {
      // Regular case: the server sends us its aggregation result which will serve our
      // own aggregation result.
    } else {
      // Unexpected case: for some reason, the server result is stale.
      // We proceed to the next round without its result.
      debug(`[${this.ownId}] server result is either stale or not received`);
      this.aggregator.nextRound();
    }

    return await this.aggregationResult
  }

  /**
   * Send a message containing our local weight updates to the federated server.
   * And waits for the server to reply with the most recent aggregated weights
   * @param payload The weight updates to send
   */
  private async sendPayloadAndReceiveResult(
    payload: WeightsContainer,
  ): Promise<WeightsContainer | undefined> {
    const msg: messages.SendPayload = {
      type: type.SendPayload,
      payload: await serialization.weights.encode(payload),
      round: this.aggregator.round,
    };
    this.server.send(msg);

    // Waits for the server's result for its current (most recent) round and add it to our aggregator.
    // Updates the aggregator's round if it's behind the server's.
    try {
      // It is important than the client immediately awaits the server result or it may miss it
      const { payload, round, nbOfParticipants } = await waitMessageWithTimeout(
        this.server,
        type.ReceiveServerPayload,
      );
      const serverRound = round;
      this.#nbOfParticipants = nbOfParticipants // Save the current participants

      // Store the server result only if it is not stale
      if (this.aggregator.round <= round) {
        const serverResult = serialization.weights.decode(payload);
        // Update the local round to match the server's
        if (this.aggregator.round < serverRound) {
          this.aggregator.setRound(serverRound);
        }
        return serverResult;
      }
    } catch (e) {
      debug(`[${this.ownId}] while receiving results: %o`, e);
    }
  }
}
